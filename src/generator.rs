use std::borrow::Cow;

use tracing::{event, Level};

const DEFAULT_DATA: &[Cow<'static, str>] = &[
	Cow::Borrowed("^XA"),
	Cow::Borrowed("^IDR:*.*"),
	Cow::Borrowed("^XZ"),
	Cow::Borrowed("^XA"),
	Cow::Borrowed("^SZ2"),
	Cow::Borrowed("^XZ"),
	Cow::Borrowed("^XA"),
	Cow::Borrowed("^PON"),
	Cow::Borrowed("^PW635"),
	Cow::Borrowed("^LL929"),
	Cow::Borrowed("^LH0,006"),
	Cow::Borrowed("^MNY"),
	Cow::Borrowed("^XZ"),
	Cow::Borrowed("~DGET0,1312,41,z0vX001C038038E003B80381FFE1C7FF8001FC038FFF03FFC07F00003801FFF8780E3FFF00FE003F80FFFC001C01C03870071C0387FFE1C7FF8007FF038FFF0FFFC0FFC0003801FFF8780E3FFF03FF807FE0FFFC001C00E03870070E0387FFE1C7FF800FFF838FFF0FFFC1FFE0003801FFF87C0E3FFF0FFFC0FFF0FFFC001C00E03870070E038F00E1C003801F07C380071E01C1E1F000380000387C0E00070F83E0F0F8001C001C0070383FFE07038E00E1C003800C01C380071C01C3807000380000387E0E00070E00E1C038001C001C0078383FFE07838E00E1C0038J01E380071C01C380700038000038770E00070E00F1C038001C001C003C381FFC03C38F00E1C0038J00E380071E01C380703FF8000038730E00070FE071C038001C001C001FF81C1C01FF87FFE1C0038J00E380070FFFC380707FF800FFF8738E1FFF0FE071C0387FFC003E007FF81C1C07FF83FFE1C0038J00E3800707FFC38070FFF800FFF8718E1FFF0FE071C0387FFC007700FFF80E380FFF83FFE1C0038J00E3800707FFC38071E03800FFF871CE1FFF000071C0387FFC007701E0380E381E038780E1C0038J00E380070F01C38071C03800003870EE0007000071C038001C00E381C03807701C038700E1C0038J01E380070E01C38071C038000038706E00070000F1C038001C01C1C1C03807701C038700E1C003800C01C380070E01C38071C038000038707E00070600E1C038001C01C1C1E03807701E038780E1C003801F07C380070F01C38071E038000038703E00070F83E1C038001C0380E0FFF803E00FFF87FFE1C003800FFF8380070FFFC38070FFF801FFF8703E3FFF07FFC1C038FFFC0780F0FFF803E00FFF83FFE1C0038007FF03800707FFC380707FF801FFF8701E3FFF03FF81C038FFFC0700703FF801C003FF80FFE1C0038001FC03800701FFC380703FF801FFF8700E3FFF00FE01C038FFFC0z0jR0")
];

pub fn generate_zpl(num: u32) -> String {
	event!(Level::TRACE, %num, "generating zpl");
	let mut num_bytes = num.to_string().into_bytes();

	let orig_num = num;
	let check_digit_byte = crate::check_digit::digit_checksum(&num_bytes);
	num_bytes.extend(check_digit_byte);
	let num = String::from_utf8(num_bytes).unwrap();
	let mut output = DEFAULT_DATA.to_vec();
	output.extend_from_slice(&[
		Cow::Borrowed("^XA"),
		Cow::Owned(format!("^FX{orig_num}")),
		Cow::Borrowed("^PMN"),
		Cow::Borrowed("^LRN"),
		Cow::Owned(format!("^FO200,335^A0I,37,53^FD{num:0>8}^FS")),
		Cow::Borrowed("^BY3,2.0"),
		Cow::Owned(format!("^FO150,385^BKI,N,60,N,N,A,B^FD{num:0>8}^FS")),
		Cow::Owned(format!("^FO200,65^A0I,37,53^FD{num:0>8}^FS")),
		Cow::Owned(format!("^FO200,160^A0I,37,53^FD{num:0>8}^FS")),
		Cow::Borrowed("^BY3,2.0"),
		Cow::Owned(format!("^FO150,210^BKI,N,60,N,N,A,B^FD{num:0>8}^FS")),
		Cow::Borrowed("^FO140,270^XGET0^FS"),
		Cow::Borrowed("^RS8,,,3,N"),
		Cow::Owned(format!(
			"^RFW,H,4,8^FD{:0>8X}^FS",
			flip_endian(num.parse().unwrap())
		)),
		Cow::Borrowed("^PQ1,0,1,Y"),
		Cow::Borrowed("^XZ"),
	]);

	output.join("\n")
}

#[cfg(target_endian = "big")]
const fn flip_endian(s: u32) -> u32 {
	s.to_le()
}

#[cfg(target_endian = "little")]
const fn flip_endian(s: u32) -> u32 {
	s.to_be()
}
